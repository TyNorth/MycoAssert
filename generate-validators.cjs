const fs = require('fs')
const path = require('path')

/**
 * Generates the content for a .d.ts TypeScript declaration file. (No changes needed here)
 */
function generateDtsContent(schemas) {
  let dtsContent = `// Auto-generated by MycoAssert. Do not edit.\n`
  dtsContent += `// Generated at ${new Date().toISOString()}\n\n`
  for (const typeName in schemas) {
    dtsContent += `export interface ${typeName} {\n`
    const schema = schemas[typeName]
    for (let key in schema) {
      const rules = schema[key]
      const isOptional = key.endsWith('?')
      const propertyName = isOptional ? key.slice(0, -1) : key
      // The final type after a 'toInt' transform is a number
      const finalType = rules.transform && rules.transform.includes('toInt') ? 'number' : rules.type
      let tsType = schemas[finalType] ? finalType : finalType === 'array' ? 'any[]' : finalType
      dtsContent += `  ${propertyName}${isOptional ? '?' : ''}: ${tsType};\n`
    }
    dtsContent += `}\n\n`
  }
  for (const typeName in schemas) {
    // The return type is 'any' because in verbose mode it's an object, in assertion mode it's a boolean
    dtsContent += `export function validate${typeName}(data: any, options?: { verbose: boolean }): any;\n`
  }
  return dtsContent
}

/**
 * Generates the JavaScript validation functions as a single string.
 */
/**
 * Generates the JavaScript validation functions as a single string.
 */
function generateValidatorsString(schemas) {
  let outputCode = `// THIS FILE IS AUTO-GENERATED BY ASSERTIFY. DO NOT EDIT.\n`
  outputCode += `// Generated at ${new Date().toISOString()}\n\n`

  // This structure allows nested/recursive validators to find each other
  const allFunctionNames = Object.keys(schemas)
  outputCode += `let ${allFunctionNames.map((name) => `validate${name}`).join(', ')};\n\n`

  for (const typeName in schemas) {
    const schema = schemas[typeName]
    let functionBody = `function _validate${typeName}(data, options = {}) {\n`
    functionBody += `  const isVerbose = options.verbose === true;\n`
    functionBody += `  const errors = [];\n`
    functionBody += `  if (typeof data !== 'object' || data === null) {\n`
    functionBody += `    const message = '${typeName} must be a non-null object.';\n`
    functionBody += `    if (isVerbose) return { isValid: false, errors: [{ property: null, rule: 'type', message }], value: undefined };\n`
    functionBody += `    else throw new Error(message);\n`
    functionBody += `  }\n\n`
    functionBody += `  const sanitizedValue = { ...data };\n\n`

    for (let key in schema) {
      const rules = schema[key]
      const isOptional = key.endsWith('?')
      const propertyName = isOptional ? key.slice(0, -1) : key
      const errorHandlingLogic = (rule, message) => {
        const errorMessage = `Validation failed for ${typeName}.${propertyName}: ${message}`
        const errorObject = `{ property: '${propertyName}', rule: '${rule}', message: \`${message.replace(/`/g, '\\`')}\`, value: sanitizedValue.${propertyName} }`
        return `if (isVerbose) { errors.push(${errorObject}); } else { throw new Error(\`${errorMessage.replace(/`/g, '\\`')}\`); }`
      }
      functionBody += `  // --- Validation for property: ${propertyName} ---\n`
      functionBody += `  if (sanitizedValue.hasOwnProperty('${propertyName}')) {\n`

      if (rules.transform) {
        if (rules.transform.includes('trim'))
          functionBody += `    if(typeof sanitizedValue.${propertyName} === 'string') sanitizedValue.${propertyName} = sanitizedValue.${propertyName}.trim();\n`
        if (rules.transform.includes('toLowerCase'))
          functionBody += `    if(typeof sanitizedValue.${propertyName} === 'string') sanitizedValue.${propertyName} = sanitizedValue.${propertyName}.toLowerCase();\n`
        if (rules.transform.includes('toInt')) {
          functionBody += `    const parsedInt = parseInt(sanitizedValue.${propertyName}, 10);\n`
          functionBody += `    if (!Number.isNaN(parsedInt)) { sanitizedValue.${propertyName} = parsedInt; } else { ${errorHandlingLogic('transform', 'failed to transform to integer (resulted in NaN).')} }\n`
        }
      }

      const finalType = rules.transform && rules.transform.includes('toInt') ? 'number' : rules.type
      if (schemas[finalType]) {
        functionBody += `    try { validate${finalType}(sanitizedValue.${propertyName}, options); } catch (e) { if (!isVerbose) { throw new Error(\`Validation failed for ${typeName}.${propertyName}: \` + e.message); } else { errors.push({ property: '${propertyName}', rule: 'nested', message: e.message }); } }\n`
      } else {
        const typeCheck =
          finalType === 'array'
            ? `!Array.isArray(sanitizedValue.${propertyName})`
            : `typeof sanitizedValue.${propertyName} !== '${finalType}'`
        functionBody += `    if (${typeCheck}) { ${errorHandlingLogic('type', `expected final type '${finalType}' but got '\${typeof sanitizedValue.${propertyName}}'`)} }\n`
        functionBody += `    else {\n`
        if (rules.type === 'string') {
          if (rules.minLength !== undefined)
            functionBody += `      if (String(sanitizedValue.${propertyName}).length < ${rules.minLength}) { ${errorHandlingLogic('minLength', `must be at least ${rules.minLength} characters long.`)} }\n`
          // --- THIS IS THE MISSING LOGIC ---
          if (rules.pattern)
            functionBody += `      if (!/${rules.pattern}/.test(sanitizedValue.${propertyName})) { ${errorHandlingLogic('pattern', `does not match required format.`)} }\n`
          // ------------------------------------
          if (rules.startsWith)
            functionBody += `      if (!String(sanitizedValue.${propertyName}).startsWith('${rules.startsWith}')) { ${errorHandlingLogic('startsWith', `must start with '${rules.startsWith}'.`)} }\n`
        }
        if (finalType === 'number') {
          if (rules.min !== undefined)
            functionBody += `      if (sanitizedValue.${propertyName} < ${rules.min}) { ${errorHandlingLogic('min', `must be at least ${rules.min}.`)} }\n`
          if (rules.isInteger)
            functionBody += `      if (!Number.isInteger(sanitizedValue.${propertyName})) { ${errorHandlingLogic('isInteger', 'must be an integer.')} }\n`
        }
        if (rules.type === 'array') {
          if (rules.minLength !== undefined)
            functionBody += `      if (sanitizedValue.${propertyName}.length < ${rules.minLength}) { ${errorHandlingLogic('minLength', `must contain at least ${rules.minLength} items.`)} }\n`
          if (rules.items) {
            functionBody += `      for (let i = 0; i < sanitizedValue.${propertyName}.length; i++) {\n`
            functionBody += `        const item = sanitizedValue.${propertyName}[i];\n`
            if (rules.items.type === 'string' && rules.items.minLength)
              functionBody += `        if (typeof item !== 'string' || item.length < ${rules.items.minLength}) { ${errorHandlingLogic('itemValidation', `item at index \${i} is invalid.`)} }\n`
            functionBody += `      }\n`
          }
        }
        functionBody += `    }\n`
      }
      functionBody += `  } else if (!${isOptional}) {\n`
      functionBody += `    ${errorHandlingLogic('required', 'is a required property.')}\n`
      functionBody += `  }\n\n`
    }

    functionBody += `  if (isVerbose) return { isValid: errors.length === 0, errors, value: errors.length === 0 ? sanitizedValue : undefined };\n`
    functionBody += `  return true;\n`
    functionBody += `}\n`
    outputCode += functionBody
  }

  allFunctionNames.forEach((name) => {
    outputCode += `validate${name} = _validate${name};\n`
  })
  outputCode += `export { ${allFunctionNames.map((name) => `validate${name}`).join(', ')} };\n`
  return outputCode
}

/**
 * The main orchestration function. This now includes the EXPLICIT DELETE step.
 */
function runGeneration() {
  const shouldGenerateDts = process.argv.includes('--dts') || process.argv.includes('--watch')
  console.log('\n--- Running MycoAssert Generation ---')

  try {
    const typesFilePath = path.join(__dirname, 'types.json')
    const outputFilePath = path.join(__dirname, 'src/validators.js')
    const dtsOutputFilePath = path.join(__dirname, 'src/validators.d.ts')

    // --- NEW: Explicitly delete old files to guarantee a clean slate ---
    if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath)
    if (fs.existsSync(dtsOutputFilePath)) fs.unlinkSync(dtsOutputFilePath)
    console.log('Cleared old generated files.')
    // -----------------------------------------------------------------

    const schemas = JSON.parse(fs.readFileSync(typesFilePath, 'utf8'))

    const outputCode = generateValidatorsString(schemas)
    fs.writeFileSync(outputFilePath, outputCode, 'utf8')
    console.log(`âœ… Wrote: ${outputFilePath}`)

    if (shouldGenerateDts) {
      const dtsContent = generateDtsContent(schemas)
      fs.writeFileSync(dtsOutputFilePath, dtsContent, 'utf8')
      console.log(`âœ… Wrote: ${dtsOutputFilePath}`)
    }
    console.log('--- Generation Complete ---')
  } catch (error) {
    console.error('âŒ MycoAssert Error:', error.message)
    if (!process.argv.includes('--watch')) {
      process.exit(1)
    }
  }
}

// --- Exports for Testing (No changes needed here) ---
module.exports = {
  generateValidatorsString,
  generateDtsContent,
}

// --- Script Entry Point (No changes needed here) ---
if (require.main === module) {
  const yargs = require('yargs/yargs')
  const { hideBin } = require('yargs/helpers')

  const argv = yargs(hideBin(process.argv))
    .option('watch', { alias: 'w', type: 'boolean', description: 'Watch for changes' })
    .option('dts', { alias: 'd', type: 'boolean', description: 'Generate .d.ts file' })
    .help()
    .alias('help', 'h').argv

  if (argv.watch) {
    const chokidar = require('chokidar')
    const typesFilePath = path.join(__dirname, 'types.json')
    console.log(`ðŸ‘€ MycoAssert is now watching ${typesFilePath} for changes...`)

    runGeneration() // Initial run

    const watcher = chokidar.watch(typesFilePath, { persistent: true, ignoreInitial: true })
    watcher.on('change', () => runGeneration())
  } else {
    runGeneration()
  }
}
